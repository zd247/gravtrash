"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const React = require("react");
const react_native_1 = require("react-native");
const react_native_gesture_handler_1 = require("react-native-gesture-handler");
const get_spring_config_1 = require("./utils/get-spring-config");
const devices_1 = require("./utils/devices");
const has_absolute_style_1 = require("./utils/has-absolute-style");
const styles_1 = require("./styles");
const { height: screenHeight } = react_native_1.Dimensions.get('window');
const AnimatedKeyboardAvoidingView = react_native_1.Animated.createAnimatedComponent(react_native_1.KeyboardAvoidingView);
const AnimatedFlatList = react_native_1.Animated.createAnimatedComponent(react_native_1.FlatList);
const AnimatedSectionList = react_native_1.Animated.createAnimatedComponent(react_native_1.SectionList);
const GestureHandlerWrapper = react_native_gesture_handler_1.GestureHandlerRootView !== null && react_native_gesture_handler_1.GestureHandlerRootView !== void 0 ? react_native_gesture_handler_1.GestureHandlerRootView : react_native_1.View;
const USE_NATIVE_DRIVER = true;
const ACTIVATED = 20;
const PAN_DURATION = 150;
class Modalize extends React.Component {
    constructor(props) {
        super(props);
        this.snaps = [];
        this.cancelTranslateY = new react_native_1.Animated.Value(1); // 1 by default to have the translateY animation running
        this.beginScrollYValue = 0;
        this.beginScrollY = new react_native_1.Animated.Value(0);
        this.dragY = new react_native_1.Animated.Value(0);
        this.translateY = new react_native_1.Animated.Value(screenHeight);
        this.modal = React.createRef();
        this.modalChildren = React.createRef();
        this.modalContentView = React.createRef();
        this.contentView = React.createRef();
        this.modalOverlay = React.createRef();
        this.modalOverlayTap = React.createRef();
        this.willCloseModalize = false;
        this.initialComputedModalHeight = 0;
        this.open = (dest) => {
            const { onOpen, alwaysOpen } = this.props;
            if (onOpen) {
                onOpen();
            }
            this.onAnimateOpen(alwaysOpen, dest);
        };
        this.close = (dest) => {
            const { onClose } = this.props;
            if (onClose) {
                onClose();
            }
            this.onAnimateClose(dest);
        };
        this.scrollTo = (...args) => {
            if (this.contentView.current) {
                const ref = this.contentView.current;
                // since RN 0.62 the getNode call has been deprecated
                const scrollResponder = ref.getScrollResponder
                    ? ref.getScrollResponder()
                    : ref.getNode().getScrollResponder();
                scrollResponder.scrollTo(...args);
            }
        };
        this.scrollToIndex = (...args) => {
            const { flatListProps } = this.props;
            if (!flatListProps) {
                return console.error(`[react-native-modalize] You can't use the 'scrollToIndex' method with something else than the FlatList component.`);
            }
            if (this.contentView.current) {
                const ref = this.contentView.current;
                ref.getNode().scrollToIndex(...args);
            }
        };
        this.onAnimateOpen = (alwaysOpen, dest = 'default') => {
            const { onOpened, snapPoint, useNativeDriver, openAnimationConfig, onPositionChange, panGestureAnimatedValue, } = this.props;
            const { timing, spring } = openAnimationConfig;
            const { overlay, modalHeight } = this.state;
            react_native_1.BackHandler.addEventListener('hardwareBackPress', this.onBackPress);
            let toValue = 0;
            let toPanValue = 0;
            if (dest === 'top') {
                toValue = 0;
            }
            else if (alwaysOpen) {
                toValue = (modalHeight || 0) - alwaysOpen;
            }
            else if (snapPoint) {
                toValue = (modalHeight || 0) - snapPoint;
            }
            if (panGestureAnimatedValue && (alwaysOpen || snapPoint)) {
                toPanValue = 0;
            }
            else if (panGestureAnimatedValue && !alwaysOpen && (dest === 'top' || dest === 'default')) {
                toPanValue = 1;
            }
            this.setState({
                isVisible: true,
                showContent: true,
            });
            if ((alwaysOpen && dest !== 'top') || (snapPoint && dest === 'default')) {
                this.modalPosition = 'initial';
            }
            else {
                this.modalPosition = 'top';
            }
            react_native_1.Animated.parallel([
                react_native_1.Animated.timing(overlay, {
                    toValue: alwaysOpen && dest === 'default' ? 0 : 1,
                    duration: timing.duration,
                    easing: react_native_1.Easing.ease,
                    useNativeDriver: USE_NATIVE_DRIVER,
                }),
                panGestureAnimatedValue
                    ? react_native_1.Animated.timing(panGestureAnimatedValue, {
                        toValue: toPanValue,
                        duration: PAN_DURATION,
                        useNativeDriver,
                    })
                    : react_native_1.Animated.delay(0),
                spring
                    ? react_native_1.Animated.spring(this.translateY, Object.assign(Object.assign({}, get_spring_config_1.getSpringConfig(spring)), { toValue, useNativeDriver: USE_NATIVE_DRIVER }))
                    : react_native_1.Animated.timing(this.translateY, {
                        toValue,
                        duration: timing.duration,
                        easing: timing.easing,
                        useNativeDriver: USE_NATIVE_DRIVER,
                    }),
            ]).start(() => {
                if (onOpened) {
                    onOpened();
                }
                if (onPositionChange) {
                    onPositionChange(this.modalPosition);
                }
            });
        };
        this.onAnimateClose = (dest = 'default') => {
            const { onClosed, useNativeDriver, snapPoint, closeAnimationConfig, alwaysOpen, onPositionChange, panGestureAnimatedValue, } = this.props;
            const { timing, spring } = closeAnimationConfig;
            const { overlay, modalHeight } = this.state;
            const lastSnap = snapPoint ? this.snaps[1] : 80;
            const toInitialAlwaysOpen = dest === 'alwaysOpen' && Boolean(alwaysOpen);
            const toValue = toInitialAlwaysOpen ? (modalHeight || 0) - alwaysOpen : screenHeight;
            react_native_1.BackHandler.removeEventListener('hardwareBackPress', this.onBackPress);
            this.beginScrollYValue = 0;
            this.beginScrollY.setValue(0);
            react_native_1.Animated.parallel([
                react_native_1.Animated.timing(overlay, {
                    toValue: 0,
                    duration: timing.duration,
                    easing: react_native_1.Easing.ease,
                    useNativeDriver: USE_NATIVE_DRIVER,
                }),
                panGestureAnimatedValue
                    ? react_native_1.Animated.timing(panGestureAnimatedValue, {
                        toValue: 0,
                        duration: PAN_DURATION,
                        useNativeDriver,
                    })
                    : react_native_1.Animated.delay(0),
                spring
                    ? react_native_1.Animated.spring(this.translateY, Object.assign(Object.assign({}, get_spring_config_1.getSpringConfig(spring)), { toValue, useNativeDriver: USE_NATIVE_DRIVER }))
                    : react_native_1.Animated.timing(this.translateY, {
                        duration: timing.duration,
                        easing: react_native_1.Easing.out(react_native_1.Easing.ease),
                        toValue,
                        useNativeDriver: USE_NATIVE_DRIVER,
                    }),
            ]).start(() => {
                if (onClosed) {
                    onClosed();
                }
                if (alwaysOpen && dest === 'alwaysOpen' && onPositionChange) {
                    onPositionChange('initial');
                }
                if (alwaysOpen && dest === 'alwaysOpen') {
                    this.modalPosition = 'initial';
                }
                this.setState({ showContent: toInitialAlwaysOpen });
                this.translateY.setValue(toValue);
                this.dragY.setValue(0);
                this.willCloseModalize = false;
                this.setState({
                    lastSnap,
                    isVisible: toInitialAlwaysOpen,
                });
            });
        };
        this.onModalizeContentLayout = ({ nativeEvent: { layout } }) => {
            const { adjustToContentHeight } = this.props;
            const { keyboardHeight } = this.state;
            this.setState({
                modalHeight: Math.min(layout.height + (!adjustToContentHeight || keyboardHeight ? layout.y : 0), this.initialComputedModalHeight -
                    react_native_1.Platform.select({
                        ios: 0,
                        android: keyboardHeight,
                    })),
            });
        };
        this.onContentViewLayout = ({ nativeEvent }) => {
            const { adjustToContentHeight, disableScrollIfPossible, onLayout } = this.props;
            if (onLayout) {
                onLayout(nativeEvent);
            }
            if (!adjustToContentHeight) {
                return;
            }
            const { height } = nativeEvent.layout;
            const shorterHeight = height < this.initialComputedModalHeight;
            const disableScroll = shorterHeight && disableScrollIfPossible;
            this.setState({ disableScroll });
        };
        this.onHandleComponent = ({ nativeEvent }) => {
            if (nativeEvent.oldState === react_native_gesture_handler_1.State.BEGAN) {
                this.beginScrollY.setValue(0);
            }
            this.onHandleChildren({ nativeEvent });
        };
        this.onHandleChildren = ({ nativeEvent }) => {
            const { snapPoint, useNativeDriver, adjustToContentHeight, alwaysOpen, closeAnimationConfig, dragToss, onPositionChange, panGestureAnimatedValue, threshold, velocity, } = this.props;
            const { timing } = closeAnimationConfig;
            const { lastSnap, modalHeight, overlay } = this.state;
            const { velocityY, translationY } = nativeEvent;
            const enableBounces = devices_1.isAndroid ? false : this.beginScrollYValue > 0 || translationY < 0;
            const thresholdProps = translationY > (adjustToContentHeight ? (modalHeight || 0) / 3 : threshold) &&
                this.beginScrollYValue === 0;
            const closeThreshold = velocity
                ? (this.beginScrollYValue <= 20 && velocityY >= velocity) || thresholdProps
                : thresholdProps;
            this.setState({ enableBounces });
            /*
             * When the pan gesture began we check the position of the scrollview "cursor".
             * We cancel the translation animation if the scrolview is not scrolled to the top
             */
            if (nativeEvent.oldState === react_native_gesture_handler_1.State.BEGAN) {
                if (this.beginScrollYValue > 0) {
                    this.translateY.setValue(0);
                    this.dragY.setValue(0);
                    this.cancelTranslateY.setValue(0);
                }
                else {
                    this.cancelTranslateY.setValue(1);
                }
            }
            if (nativeEvent.oldState === react_native_gesture_handler_1.State.ACTIVE) {
                const toValue = translationY - this.beginScrollYValue;
                let destSnapPoint = 0;
                if (snapPoint || alwaysOpen) {
                    const endOffsetY = lastSnap + toValue + dragToss * velocityY;
                    this.snaps.forEach((snap) => {
                        const distFromSnap = Math.abs(snap - endOffsetY);
                        if (distFromSnap < Math.abs(destSnapPoint - endOffsetY)) {
                            destSnapPoint = snap;
                            this.willCloseModalize = false;
                            if (alwaysOpen) {
                                destSnapPoint = (modalHeight || 0) - alwaysOpen;
                            }
                            if (snap === this.snapEnd && !alwaysOpen) {
                                this.willCloseModalize = true;
                                this.close();
                            }
                        }
                    });
                }
                else if (closeThreshold && !alwaysOpen) {
                    this.willCloseModalize = true;
                    this.close();
                }
                if (this.willCloseModalize) {
                    return;
                }
                this.setState({ lastSnap: destSnapPoint });
                this.translateY.extractOffset();
                this.translateY.setValue(toValue);
                this.translateY.flattenOffset();
                this.dragY.setValue(0);
                if (alwaysOpen) {
                    react_native_1.Animated.timing(overlay, {
                        toValue: Number(destSnapPoint <= 0),
                        duration: timing.duration,
                        easing: react_native_1.Easing.ease,
                        useNativeDriver: USE_NATIVE_DRIVER,
                    }).start();
                }
                react_native_1.Animated.spring(this.translateY, {
                    tension: 50,
                    friction: 12,
                    velocity: velocityY,
                    toValue: destSnapPoint,
                    useNativeDriver: USE_NATIVE_DRIVER,
                }).start();
                if (this.beginScrollYValue === 0) {
                    const modalPosition = Boolean(destSnapPoint <= 0) ? 'top' : 'initial';
                    if (panGestureAnimatedValue) {
                        react_native_1.Animated.timing(panGestureAnimatedValue, {
                            toValue: Number(modalPosition === 'top'),
                            duration: PAN_DURATION,
                            useNativeDriver,
                        }).start();
                    }
                    if (!adjustToContentHeight && modalPosition === 'top') {
                        this.setState({ disableScroll: false });
                    }
                    if (onPositionChange && this.modalPosition !== modalPosition) {
                        onPositionChange(modalPosition);
                    }
                    if (this.modalPosition !== modalPosition) {
                        this.modalPosition = modalPosition;
                    }
                }
            }
        };
        this.onHandleOverlay = ({ nativeEvent }) => {
            const { alwaysOpen, onOverlayPress } = this.props;
            if (nativeEvent.oldState === react_native_gesture_handler_1.State.ACTIVE && !this.willCloseModalize) {
                if (onOverlayPress) {
                    onOverlayPress();
                }
                const dest = !!alwaysOpen ? 'alwaysOpen' : 'default';
                this.close(dest);
            }
        };
        this.onBackPress = () => {
            const { onBackButtonPress, alwaysOpen } = this.props;
            if (alwaysOpen) {
                return false;
            }
            if (onBackButtonPress) {
                return onBackButtonPress();
            }
            else {
                this.close();
            }
            return true;
        };
        this.onKeyboardShow = (event) => {
            const { height } = event.endCoordinates;
            this.setState({ keyboardToggle: true, keyboardHeight: height });
        };
        this.onKeyboardHide = () => {
            this.setState({ keyboardToggle: false, keyboardHeight: 0 });
        };
        this.onGestureEvent = react_native_1.Animated.event([{ nativeEvent: { translationY: this.dragY } }], {
            useNativeDriver: USE_NATIVE_DRIVER,
            listener: ({ nativeEvent: { translationY } }) => {
                const { panGestureAnimatedValue } = this.props;
                const offset = 200;
                if (panGestureAnimatedValue) {
                    const diff = Math.abs(translationY / (this.initialComputedModalHeight - offset));
                    const y = translationY < 0 ? diff : 1 - diff;
                    let value;
                    if (this.modalPosition === 'initial' && translationY > 0) {
                        value = 0;
                    }
                    else if (this.modalPosition === 'top' && translationY <= 0) {
                        value = 1;
                    }
                    else {
                        value = y;
                    }
                    panGestureAnimatedValue.setValue(value);
                }
            },
        });
        this.renderComponent = (Tag) => {
            return React.isValidElement(Tag) ? (Tag) : (
            // @ts-ignore
            React.createElement(Tag, null));
        };
        this.renderHandle = () => {
            const { handleStyle, withHandle, panGestureEnabled } = this.props;
            const handleStyles = [styles_1.default.handle];
            const shapeStyles = [styles_1.default.handle__shape, handleStyle];
            if (!withHandle) {
                return null;
            }
            if (!this.isHandleOutside) {
                handleStyles.push(styles_1.default.handleBottom);
                shapeStyles.push(styles_1.default.handle__shapeBottom, handleStyle);
            }
            return (React.createElement(react_native_gesture_handler_1.PanGestureHandler, { enabled: panGestureEnabled, simultaneousHandlers: this.modal, shouldCancelWhenOutside: false, onGestureEvent: this.onGestureEvent, onHandlerStateChange: this.onHandleComponent },
                React.createElement(react_native_1.Animated.View, { style: handleStyles },
                    React.createElement(react_native_1.View, { style: shapeStyles }))));
        };
        this.renderHeader = () => {
            const { HeaderComponent, panGestureEnabled } = this.props;
            if (!HeaderComponent) {
                return null;
            }
            if (has_absolute_style_1.hasAbsoluteStyle(HeaderComponent)) {
                return this.renderComponent(HeaderComponent);
            }
            return (React.createElement(react_native_gesture_handler_1.PanGestureHandler, { enabled: panGestureEnabled, simultaneousHandlers: this.modal, shouldCancelWhenOutside: false, onGestureEvent: this.onGestureEvent, onHandlerStateChange: this.onHandleComponent },
                React.createElement(react_native_1.Animated.View, { style: styles_1.default.component }, this.renderComponent(HeaderComponent))));
        };
        this.renderContent = () => {
            const { children, scrollViewProps, flatListProps, sectionListProps } = this.props;
            const { enableBounces, disableScroll, keyboardToggle } = this.state;
            const keyboardDismissMode = devices_1.isIos ? 'interactive' : 'on-drag';
            const opts = {
                ref: this.contentView,
                bounces: enableBounces,
                onScrollBeginDrag: react_native_1.Animated.event([{ nativeEvent: { contentOffset: { y: this.beginScrollY } } }], { useNativeDriver: USE_NATIVE_DRIVER }),
                scrollEventThrottle: 16,
                onLayout: this.onContentViewLayout,
                scrollEnabled: keyboardToggle || !disableScroll,
                keyboardDismissMode,
            };
            if (flatListProps) {
                return React.createElement(AnimatedFlatList, Object.assign({}, opts, flatListProps));
            }
            if (sectionListProps) {
                return React.createElement(AnimatedSectionList, Object.assign({}, opts, sectionListProps));
            }
            return (React.createElement(react_native_1.Animated.ScrollView, Object.assign({}, opts, scrollViewProps), children));
        };
        this.renderChildren = () => {
            const { adjustToContentHeight, panGestureEnabled } = this.props;
            const style = adjustToContentHeight ? styles_1.default.content__adjustHeight : styles_1.default.content__container;
            return (React.createElement(react_native_gesture_handler_1.PanGestureHandler, { ref: this.modalChildren, enabled: panGestureEnabled, simultaneousHandlers: [this.modalContentView, this.modal], shouldCancelWhenOutside: false, onGestureEvent: this.onGestureEvent, minDist: ACTIVATED, activeOffsetY: ACTIVATED, activeOffsetX: ACTIVATED, onHandlerStateChange: this.onHandleChildren },
                React.createElement(react_native_1.Animated.View, { style: style },
                    React.createElement(react_native_gesture_handler_1.NativeViewGestureHandler, { ref: this.modalContentView, waitFor: this.modal, simultaneousHandlers: this.modalChildren }, this.renderContent()))));
        };
        this.renderFooter = () => {
            const { FooterComponent } = this.props;
            if (!FooterComponent) {
                return null;
            }
            return this.renderComponent(FooterComponent);
        };
        this.renderFloatingComponent = () => {
            const { FloatingComponent } = this.props;
            if (!FloatingComponent) {
                return null;
            }
            return this.renderComponent(FloatingComponent);
        };
        this.renderOverlay = () => {
            const { overlayStyle, alwaysOpen, panGestureEnabled, closeOnOverlayTap } = this.props;
            const { showContent } = this.state;
            const pointerEvents = alwaysOpen && (this.modalPosition === 'initial' || !this.modalPosition) ? 'box-none' : 'auto';
            return (React.createElement(react_native_gesture_handler_1.PanGestureHandler, { ref: this.modalOverlay, enabled: panGestureEnabled, simultaneousHandlers: [this.modal], shouldCancelWhenOutside: false, onGestureEvent: this.onGestureEvent, onHandlerStateChange: this.onHandleChildren },
                React.createElement(react_native_1.Animated.View, { style: styles_1.default.overlay, pointerEvents: pointerEvents }, showContent && (React.createElement(react_native_gesture_handler_1.TapGestureHandler, { ref: this.modalOverlayTap, enabled: panGestureEnabled || closeOnOverlayTap, onHandlerStateChange: this.onHandleOverlay },
                    React.createElement(react_native_1.Animated.View, { style: [styles_1.default.overlay__background, overlayStyle, this.overlayBackground], pointerEvents: pointerEvents }))))));
        };
        this.renderModalize = () => {
            const { keyboardAvoidingOffset, modalStyle, keyboardAvoidingBehavior, alwaysOpen, panGestureEnabled, avoidKeyboardLikeIOS, adjustToContentHeight, modalElevation: elevation, withOverlay, } = this.props;
            const { isVisible, lastSnap, showContent } = this.state;
            const pointerEvents = alwaysOpen || !withOverlay ? 'box-none' : 'auto';
            const keyboardAvoidingViewProps = {
                keyboardVerticalOffset: keyboardAvoidingOffset,
                behavior: keyboardAvoidingBehavior || 'padding',
                enabled: avoidKeyboardLikeIOS,
                style: [styles_1.default.modalize__content, this.modalizeContent, modalStyle],
            };
            if (!avoidKeyboardLikeIOS && !adjustToContentHeight) {
                keyboardAvoidingViewProps.onLayout = this.onModalizeContentLayout;
            }
            if (!isVisible) {
                return null;
            }
            return (React.createElement(GestureHandlerWrapper, { style: [styles_1.default.modalize, { elevation }], pointerEvents: pointerEvents },
                React.createElement(react_native_gesture_handler_1.TapGestureHandler, { ref: this.modal, maxDurationMs: 100000, maxDeltaY: lastSnap, enabled: panGestureEnabled },
                    React.createElement(react_native_1.View, { style: styles_1.default.modalize__wrapper, pointerEvents: "box-none" },
                        showContent && (React.createElement(AnimatedKeyboardAvoidingView, Object.assign({}, keyboardAvoidingViewProps),
                            this.renderHandle(),
                            this.renderHeader(),
                            this.renderChildren(),
                            this.renderFooter())),
                        withOverlay && this.renderOverlay())),
                this.renderFloatingComponent()));
        };
        this.renderReactModal = (child) => {
            const { isVisible } = this.state;
            return (React.createElement(react_native_1.Modal, { supportedOrientations: ['landscape', 'portrait', 'portrait-upside-down'], onRequestClose: this.onBackPress, hardwareAccelerated: USE_NATIVE_DRIVER, visible: isVisible, transparent: true }, child));
        };
        const fullHeight = screenHeight - props.modalTopOffset;
        const computedHeight = fullHeight - this.handleHeight - (devices_1.isIphoneX ? 34 : 0);
        const modalHeight = props.modalHeight || computedHeight;
        this.initialComputedModalHeight = modalHeight;
        if (props.modalHeight && props.adjustToContentHeight) {
            console.error(`[react-native-modalize] You can't use both 'modalHeight' and 'adjustToContentHeight' props at the same time. Only choose one of the two.`);
        }
        if ((props.scrollViewProps || props.children) && props.flatListProps) {
            console.error(`[react-native-modalize] You have defined 'flatListProps' along with 'scrollViewProps' or 'children' props. Remove 'scrollViewProps' or 'children' or 'flatListProps' to fix the error.`);
        }
        if ((props.scrollViewProps || props.children) && props.sectionListProps) {
            console.error(`[react-native-modalize] You have defined 'sectionListProps'  along with 'scrollViewProps' or 'children' props. Remove 'scrollViewProps' or 'children' or 'sectionListProps' to fix the error.`);
        }
        if (props.snapPoint) {
            this.snaps.push(0, modalHeight - props.snapPoint, modalHeight);
        }
        else {
            this.snaps.push(0, modalHeight);
        }
        this.snapEnd = this.snaps[this.snaps.length - 1];
        this.state = {
            lastSnap: props.snapPoint ? modalHeight - props.snapPoint : 0,
            isVisible: false,
            showContent: true,
            overlay: new react_native_1.Animated.Value(0),
            modalHeight: props.adjustToContentHeight ? undefined : modalHeight,
            contentHeight: 0,
            enableBounces: true,
            keyboardToggle: false,
            keyboardHeight: 0,
            disableScroll: props.alwaysOpen ? true : undefined,
        };
        this.beginScrollY.addListener(({ value }) => (this.beginScrollYValue = value));
        this.reverseBeginScrollY = react_native_1.Animated.multiply(new react_native_1.Animated.Value(-1), this.beginScrollY);
    }
    componentDidMount() {
        const { alwaysOpen } = this.props;
        if (alwaysOpen) {
            this.onAnimateOpen(alwaysOpen);
        }
        react_native_1.Keyboard.addListener('keyboardDidShow', this.onKeyboardShow);
        react_native_1.Keyboard.addListener('keyboardDidHide', this.onKeyboardHide);
    }
    componentDidUpdate({ adjustToContentHeight }) {
        const { adjustToContentHeight: nextAdjust } = this.props;
        if (nextAdjust !== adjustToContentHeight) {
            this.setState({
                modalHeight: nextAdjust ? undefined : this.initialComputedModalHeight,
            });
        }
    }
    componentWillUnmount() {
        react_native_1.BackHandler.removeEventListener('hardwareBackPress', this.onBackPress);
        react_native_1.Keyboard.removeListener('keyboardDidShow', this.onKeyboardShow);
        react_native_1.Keyboard.removeListener('keyboardDidHide', this.onKeyboardHide);
    }
    get isHandleOutside() {
        const { handlePosition } = this.props;
        return handlePosition === 'outside';
    }
    get handleHeight() {
        const { withHandle } = this.props;
        if (!withHandle) {
            return 20;
        }
        return this.isHandleOutside ? 35 : 20;
    }
    get modalizeContent() {
        const { modalHeight } = this.state;
        /*
         * When we have a scrolling happening in the scrollview, we don't want to translate the modal down.
         * We either multiply by 0 to cancel the animation, or 1 to proceed.
         */
        const cancelTranslateY = (ref) => react_native_1.Animated.multiply(ref, this.cancelTranslateY);
        /*
         * We diff and get the negative value only. It sometimes go above 0 (e.g. 1.5) and creates
         * the flickering on Modalize for a ms
         */
        const diffClamp = react_native_1.Animated.diffClamp(this.reverseBeginScrollY, -screenHeight, 0);
        const dragY = react_native_1.Animated.add(cancelTranslateY(this.dragY), diffClamp);
        const value = react_native_1.Animated.add(cancelTranslateY(this.translateY), dragY);
        return {
            height: modalHeight,
            maxHeight: this.initialComputedModalHeight,
            transform: [
                {
                    translateY: value.interpolate({
                        inputRange: [-40, 0, this.snapEnd],
                        outputRange: [0, 0, this.snapEnd],
                        extrapolate: 'clamp',
                    }),
                },
            ],
        };
    }
    get overlayBackground() {
        const { overlay } = this.state;
        return {
            opacity: overlay.interpolate({
                inputRange: [0, 1],
                outputRange: [0, 1],
            }),
        };
    }
    render() {
        const { withReactModal } = this.props;
        if (withReactModal) {
            return this.renderReactModal(this.renderModalize());
        }
        return this.renderModalize();
    }
}
exports.Modalize = Modalize;
Modalize.defaultProps = {
    handlePosition: 'outside',
    useNativeDriver: true,
    adjustToContentHeight: false,
    disableScrollIfPossible: true,
    avoidKeyboardLikeIOS: react_native_1.Platform.select({
        ios: true,
        android: false,
        default: true,
    }),
    modalTopOffset: react_native_1.Platform.select({
        ios: 0,
        android: react_native_1.StatusBar.currentHeight || 0,
        default: 0,
    }),
    panGestureEnabled: true,
    closeOnOverlayTap: true,
    withReactModal: false,
    withHandle: true,
    withOverlay: true,
    openAnimationConfig: {
        timing: { duration: 280, easing: react_native_1.Easing.ease },
        spring: { speed: 14, bounciness: 4 },
    },
    closeAnimationConfig: {
        timing: { duration: 280, easing: react_native_1.Easing.ease },
    },
    dragToss: 0.05,
    threshold: 120,
    velocity: 2800,
};
